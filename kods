import requests #Bibliotēka, kas ļauj sūtīt HTTP pieprasījumus uz interneta lapām
from bs4 import BeautifulSoup #Bibliotēka, kas palīdz saprast un nolasīt HTML saturu 
from datetime import datetime #Importē datuma un laika rīkus
import random #Bibliotēka, kas ļauj izdarīt nejaušas darbības – piem., izvēlēties nejaušu citātu

BASE_URL = "https://quotes.toscrape.com" #Galvenā vietne, no kuras tiks iegūti citāti, autori un tagi

def preload_all_data(): #Funkcija, kas ielādē un saglabā visus datus no vietnes-citātus, autorus, tagus)
    all_data = {
        "authors": {}, #Saglabās autoru vārdus un viņu informāciju
        "quotes": [], #Saglabās visus atrastos citātus
        "tags": set() #Saglabās visus tagus, bez atkārtojumiem
    }
    }
    page = 1 #Sāk ar pirmo lapu
    seen_authors = set() #Saglabās autorus, kurus jau esam apstrādājuši, lai tie nedublētos

    while True:
        res = requests.get(f"{BASE_URL}/page/{page}/") #Nosūta pieprasījumu uz konkrēto lapu ar citātiem 
        if res.status_code != 200: #Pārtrauc ciklu, ja atbildes kods nav 200
            break
        soup = BeautifulSoup(res.content, "html.parser") #Izveido HTML dokumenta "lasāmu" versiju, ko Python var saprast un pārmeklēt
        
        for quote_div in soup.find_all("div", class_="quote"): #Atrod visus citātu blokus lapā – katrs citāts ir ievietots <div> ar klasi "quote"
            text = quote_div.find("span", class_="text").text  #Iegūst citāta tekstu no <span> ar klasi "text"
            author = quote_div.find("small", class_="author").text.strip() #Iegūst autora vārdu no <small> ar klasi "author" un noņem liekās atstarpes
            tags = [tag.text.strip() for tag in quote_div.find_all("a", class_="tag")] #Atrod visus tagus šim citātam un saglabā tos kā sarakstu,noņem liekās atstarpes
            all_data["quotes"].append({
                "text": text,
                "author": author,
                "tags": tags
            }) #Saglabā šo citātu, autoru un tagus kopējā sarakstā "quotes"
            all_data["tags"].update(tags) #Pievieno visus tagus kopējam tagu sarakstam, lai nav dublikātu

            if author not in seen_authors:
                seen_authors.add(author)
                link = quote_div.find("a", href=lambda href: href and href.startswith("/author/"))
                if link:
                    author_page = requests.get(BASE_URL + link["href"])
                    if author_page.status_code == 200:
                        author_soup = BeautifulSoup(author_page.content, "html.parser")
                        try:
                            birth_date = author_soup.find(class_="author-born-date").text
                            birth_place = author_soup.find(class_="author-born-location").text
                            description = author_soup.find("div", class_="author-description").text.strip()
                            birth_date_obj = datetime.strptime(birth_date, "%B %d, %Y")
                            all_data["authors"][author] = {
                                "birth_date": birth_date_obj,
                                "birth_str": birth_date,
                                "birth_place": birth_place,
                                "description": description
                            }
                        except Exception:
                            continue
        if not soup.find("li", class_="next"):
            break
        page += 1

    all_data["tags"] = sorted(all_data["tags"])
    return all_data

# ==== Funkcijas, kas izmanto ielādētos datus ====

def get_all_authors(data):
    return sorted(data["authors"].keys())

def get_author_quotes(data, author_name):
    return [q["text"] for q in data["quotes"] if q["author"].lower() == author_name.lower()]

def get_quotes_by_tag(data, tag):
    return [q["text"] for q in data["quotes"] if tag in q["tags"]]

def get_author_info(data, author_name):
    return data["authors"].get(author_name)

def get_sorted_authors_by_birth(data):
    return sorted(data["authors"].items(), key=lambda x: x[1]["birth_date"])

def get_random_quote(data):
    return random.choice(data["quotes"])

def search_quotes_by_keyword(data, keyword):
    return [q for q in data["quotes"] if keyword.lower() in q["text"].lower()]

# ==== CLI ====

print("Datu ielāde...")
data = preload_all_data()

while True:
    print("1. Citāts pēc autora")
    print("2. Citāts pēc kategorijas")
    print("3. informācija par autoru")
    print("4. Autori no vecākā uz jaunāko")
    print("5. Nejaušs citāts")
    print("6. Citāts pēc atslēgas vārda")
    print("'stop' lai pārtrauktu\n")

    choice = input("Izvēlies opciju (1-6): ").strip().lower()

    if choice == "stop":
        print("Programma pārtraukta.")
        break

    elif choice == "1":
        authors = get_all_authors(data)
        for i, a in enumerate(authors, 1):
            print(f"{i}. {a}")
        author_input = input("Ievadi autora vārdu vai numuru: ").strip()
        if author_input.isdigit():
            idx = int(author_input) - 1
            if 0 <= idx < len(authors):
                author_input = authors[idx]
            else:
                print("Nepareizs numurs.")
                continue
        quotes = get_author_quotes(data, author_input)
        if quotes:
            print(f"\nCitāti no {author_input}:")
            for q in quotes:
                print(" -", q)
        else:
            print("Nav atrasti citāti.")

    elif choice == "2":
        tags = data["tags"]
        for i, tag in enumerate(tags, 1):
            print(f"{i}. {tag}")
        tag_input = input("Ievadi tagu vai numuru: ").strip()
        if tag_input.isdigit():
            idx = int(tag_input) - 1
            if 0 <= idx < len(tags):
                tag_input = tags[idx]
            else:
                print("Nepareizs numurs.")
                continue
        quotes = get_quotes_by_tag(data, tag_input)
        if quotes:
            print(f"\nCitāti kategorijā '{tag_input}':")
            for q in quotes:
                print(" -", q)
        else:
            print("Nav atrasti citāti.")

    elif choice == "3":
        authors = get_all_authors(data)
        for i, a in enumerate(authors, 1):
            print(f"{i}. {a}")
        author_input = input("Ievadi autora vārdu vai numuru: ").strip()
        if author_input.isdigit():
            idx = int(author_input) - 1
            if 0 <= idx < len(authors):
                author_input = authors[idx]
            else:
                print("Nepareizs numurs.")
                continue
        info = get_author_info(data, author_input)
        if info:
            print(f"\nInformācija par {author_input}:")
            print("Dzimis:", info["birth_str"], info["birth_place"])
            print("Apraksts:", info["description"])
        else:
            print("Autors nav atrasts.")

    elif choice == "4":
        sorted_authors = get_sorted_authors_by_birth(data)
        print("\nAutori no vecākā uz jaunāko:")
        for i, (name, info) in enumerate(sorted_authors, 1):
            print(f"{i}. {name} (dzimis {info['birth_date'].strftime('%Y-%m-%d')})")

    elif choice == "5":
        quote = get_random_quote(data)
        print("\n Nejaušs citāts:")
        print(f'"{quote["text"]}" — {quote["author"]}')

    elif choice == "6":
        keyword = input("Ievadi atslēgvārdu/frāzi: ").strip()
        results = search_quotes_by_keyword(data, keyword)
        if results:
            print(f"\nCitāti, kuros parādās '{keyword}':")
            for q in results:
                print(f'- "{q["text"]}" — {q["author"]}')
        else:
            print("Netika atrasti citāti ar šo atslēgvārdu.")
